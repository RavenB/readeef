{% define "content" %}
<link rel="import" href="/dist/iron-collapse/iron-collapse.html">
<link rel="import" href="/dist/iron-icon/iron-icon.html">
<link rel="import" href="/dist/iron-icons/iron-icons.html">
<link rel="import" href="/dist/iron-icons/hardware-icons.html">
<link rel="import" href="/dist/iron-pages/iron-pages.html">
<link rel="import" href="/dist/iron-signals/iron-signals.html">
<link rel="import" href="/dist/more-routing/more-route-template-helpers.html">
<link rel="import" href="/dist/more-routing/more-routing.html">
<link rel="import" href="/dist/more-routing/more-routing.html">
<link rel="import" href="/dist/paper-fab/paper-fab.html">
<link rel="import" href="/dist/paper-icon-button/paper-icon-button.html">
<link rel="import" href="/dist/paper-input/paper-input.html">
<link rel="import" href="/dist/paper-item/paper-item.html">
<link rel="import" href="/dist/paper-menu-button/paper-menu-button.html">
<link rel="import" href="/dist/paper-menu/paper-menu.html">
<link rel="import" href="/dist/paper-ripple/paper-ripple.html">
<link rel="import" href="/dist/polymer/polymer.html">
<link rel="import" href="/dist/pushstate-anchor/pushstate-anchor.html">

<link rel="import" href="/component/rf-api">
<link rel="import" href="/component/rf-app-scaffold">
<link rel="import" href="/component/rf-feed">

<dom-module id="rf-feed-base">
    <style>
.drawer-menu a {
    color: var(--text-primary-color);
    text-decoration: none;
    min-height: 20px;
    font-size: 16px;

    @apply(--layout-horizontal);
    @apply(--layout-center);
}

.drawer-menu .submenu {
    margin-left: 16px;
}

.drawer-menu .submenu a {
    font-size: 14px;
}

.drawer-menu paper-icon-button.item {
    padding: 8px;
    margin-left: 4px;
}

rf-app-scaffold /deep/ .main-title-container paper-fab {
    position: fixed;
    right: 50px;
    top: 32px;
    z-index: 1;
    background: white;
}

rf-app-scaffold /deep/ .main-title-container paper-fab.notify {
    background: var(--paper-fab-notify-background);
    color: var(--text-primary-color-inverse);
}

rf-app-scaffold /deep/ .main-title-container [route="feed"] {
    margin-top: -16px;
    margin-left: -8px;
    margin-bottom: -16px;
}
rf-app-scaffold /deep/ .main-title-container [route="article"] {
    margin-top: -8px;
    margin-left: -8px;
}

/deep/ .feed-favicon {
    margin-right: 5px;
}

rf-app-scaffold /deep/ [icon="arrow-back"] {
    margin-right: 24px;
}
    </style>
    <template>
        <rf-app-scaffold narrow="{{ narrow }}">
            <div class="drawer-title">Feeds</div>
            <div class="drawer-menu">
                <div hidden$="[[  _computeHideFeedItems(feeds) ]]">
                    <a is="pushstate-anchor" href="[[ feedUrlFor('favorite') ]]" class="item">
                        <span>Favorite</span>
                        <paper-ripple></paper-ripple>
                    </a>

                    <div class="layout horizontal center">
                        <paper-icon-button icon="expand-more" expands="popular-feeds" class="item" on-tap="onToggleExpand"></paper-icon-button>
                        <a is="pushstate-anchor" href="[[ feedUrlFor('popular:all') ]]" class="layout horizontal flex">
                            <div style="position: relative" class="flex item">
                                Popular
                                <paper-ripple></paper-ripple>
                            </div>
                        </a>
                    </div>
                    <iron-collapse id="popular-feeds">
                        <div class="menu submenu">
                            <template is="dom-repeat" items="[[ tags ]]">
                                <a is="pushstate-anchor" href="[[ feedUrlFor(item.name, 'popular:tag') ]]" class="item">
                                    <span>[[ item.name ]]</span>
                                    <paper-ripple></paper-ripple>
                                </a>
                            </template>

                            <template is="dom-repeat" items="[[ feeds ]]">
                                <a is="pushstate-anchor" href="[[ feedUrlFor(item.Id, 'popular') ]]" class="item">
                                    <img src="[[ _computeFavIconUrl(item) ]]" alt="favicon" class="feed-favicon">
                                    <span>[[ item.Title ]]</span>
                                    <paper-ripple></paper-ripple>
                                </a>
                            </template>
                        </div>
                    </iron-collapse>
                    <hr>

                    <template is="dom-repeat" items="[[ _computeNavigationTags(tags) ]]">
                        <div class="layout horizontal center">
                            <paper-icon-button icon="expand-more" expands$="[[ _computeNavigationExpandTag(item) ]]" class="item" on-tap="onToggleExpand"></paper-icon-button>
                            <a is="pushstate-anchor" href="[[ repeaterTagUrl(item.name) ]]" class="layout horizontal flex">
                                <div style="position: relative" class="flex item">
                                    <span>[[ item.name ]]</span>
                                    <paper-ripple></paper-ripple>
                                </div>
                            </a>
                        </div>
                        <iron-collapse id="[[ _computeNavigationExpandTag(item) ]]">
                            <div class="menu submenu">
                                <template is="dom-repeat" items="[[ item.feeds ]]">
                                    <a is="pushstate-anchor" href="[[ feedUrlFor(item.Id) ]]" class="item">
                                        <img src="[[ _computeFavIconUrl(item) ]]" alt="favicon" class="feed-favicon">
                                        <span>[[ item.Title ]]</span>
                                        <paper-ripple></paper-ripple>
                                    </a>
                                </template>
                            </div>
                        </iron-collapse>

                    </template>
                    <hr>
                </div>
                <a is="pushstate-anchor" href="[[ urlFor('settings-general') ]]" class="item">
                    <span>Settings</span>
                    <paper-ripple></paper-ripple>
                </a>
                <a is="pushstate-anchor" href="[[ urlFor('logout') ]]" class="item">
                    <span>Logout</span>
                    <paper-ripple></paper-ripple>
                </a>
            </div>
            <div class="main-title">
                <template>
                    <more-route-selector>
                        <iron-pages>
                            <section route="feed" class="layout horizontal center flex">
                                <paper-icon-button icon="menu" paper-drawer-toggle></paper-icon-button>
                                <span class="title-text-feed flex" hidden$="[[ searchVisible ]]">
                                    <paper-icon-button icon="arrow-back" style="visibility: hidden;" hidden$="[[ narrow ]]"></paper-icon-button>
                                    <span>[[ _computeFeedTitle(tagOrId, feeds) ]]</span>
                                </span>
                                <span class="search-feed flex layout horizontal center" hidden$="[[ !searchVisible ]]">
                                    <paper-icon-button icon="clear" on-tap="toggleSearch"></paper-icon-button>
                                    <paper-input class="search-input" placeholder="Search" no-label-float on-keypress="onSearchKeypress" autofocus></paper-input>
                                </span>

                                <paper-icon-button icon="search" hidden$="[[ searchVisible ]]" on-tap="toggleSearch"></paper-icon-button>
                                <paper-menu-button horizontal-align="right">
                                    <paper-icon-button icon="more-vert" class="dropdown-trigger"></paper-icon-button>
                                    {%/* The second instance of the menu doesn't initialize its style correctly. Inline the background color */%}
                                    <paper-menu class="dropdown-content options-menu" multi attr-for-selected="name" on-iron-activate="onFeedMenuItemActivate" style="background: #fff" selected-values="[[ _computeOptionsMenuSelectedValues(user.*) ]]">
                                        <paper-item name="newer-first">Newer first</paper-item>
                                        <paper-item name="unread-only">Unread only</paper-item>
                                        <paper-item name="mark-all-as-read">Mark all as read</paper-item>
                                    </paper-menu>
                                </paper-menu-button>
                            </section>
                            <section route="article" class="layout horizontal center flex">
                                <paper-icon-button icon="arrow-back" on-tap="onArticleUp"></paper-icon-button>
                                <span class="title-text-article flex">[[ _computeFeedTitle(tagOrId, feeds) ]]</span>
                                <paper-icon-button icon="[[ _computeReadStateIcon(_readState) ]]" on-tap="onReadStateTap"></paper-icon-button>

                                <paper-icon-button icon="hardware:keyboard-arrow-left" style$="[[ _computeHideArticleArrow(_articleId, 'previous') ]]" on-tap="onPreviousArticle"></paper-icon-button>
                                <paper-icon-button icon="hardware:keyboard-arrow-right" style$="[[ _computeHideArticleArrow(_articleId, 'next') ]]" on-tap="onNextArticle"></paper-icon-button>
                            </section>
                        </iron-pages>
                    </more-route-selector>
                    <paper-fab icon="refresh" on-tap="onRefresh" hidden$="[[ narrow ]]"></paper-fab>
                </template>
            </div>
            <div class="main-content">
                <rf-feed id="feed" user="[[ user ]]" feeds="[[ feeds ]]" narrow="[[ narrow ]]" tag-or-id="[[ tagOrId ]]" on-feed-article-state="onFeedArticleState"></rf-feed>
            </div>
        </rf-app-scaffold>

        <rf-api id="list-feeds" method="list-feeds" on-rf-api-message="onAllFeedsMessage" user="{{ user }}"></rf-api>
        <rf-api id="user-settings" method="set-user-attribute" tag="feed-base" user="[[ user ]]"></rf-api>

        <iron-signals on-iron-signal-rf-feeds-added="onSignalFeedsChanged"></iron-signals>
        <iron-signals on-iron-signal-rf-feed-removed="onSignalFeedsChanged"></iron-signals>
        <iron-signals on-iron-signal-rf-feed-tags-changed="onSignalFeedTagsChanged"></iron-signals>
    </template>

    <script>
        "use strict";
        Polymer({
            is: "rf-feed-base",
            behaviors: [
                UserBehavior,
                NestedRouteBehavior,
                MoreRouting.TemplateHelpers,
            ],
            properties: {
                user: Object,
                tagOrId: String,
                feeds: {
                    type: Array,
                    notify: true,
                    observer: '_feedsChanged',
                },
                tags: Array,
                searchVisible: {
                    type: Boolean,
                    value: false,
                },
                _articleId: String,
                _readState: Boolean,
            },
            observers: [
                '_userProfileChanged(user.ProfileData.*)',
            ],
            _urlParser: document.createElement('a'),

            feedUrlFor: function(tagOrId, prefix) {
                if (prefix) {
                    tagOrId = prefix + ":" + tagOrId;
                }
                return this.urlFor('feed', {tagOrId: tagOrId})
            },

            repeaterTagUrl: function(name) {
                if (name == 'All') {
                    return this.feedUrlFor('all');
                } else {
                    return this.feedUrlFor(name, 'tag');
                }
            },

            updateTags: function() {
                var tagList = [], tags = {};

                this.feeds.forEach(function(feed) {
                    if (feed.Tags && feed.Tags.length) {
                        for (var i = 0, tag; tag = feed.Tags[i]; ++i) {
                            if (!tags[tag]) {
                                tags[tag] = [];
                            }

                            tags[tag].push(feed);
                        }
                    }
                });

                Object.keys(tags).sort().forEach(function(tag) {
                    tagList.push({name: tag, feeds: tags[tag]});
                });

                this.tags = tagList;
            },

            toggleSearch: function() {
                this.searchVisible = !this.searchVisible;
                if (this.searchVisible) {
                    // Get the currently active search input
                    var search = Polymer.dom(
                        Polymer.dom(this.root).querySelector('rf-app-scaffold').root
                    ).querySelector('.search-input');
                    if (search) {
                        search.$.input.focus();
                    }
                } else if (this.tagOrId.startsWith("search:")) {
                    var tagOrId = this._extractSearchTokens(this.tagOrId)[0];
                    MoreRouting.navigateTo('feed', {tagOrId: tagOrId});
                }
            },

            ready: function() {
                this.$['list-feeds'].send();
            },

            attached: function() {
                this.defaultNestedRoute('feed-base', 'feed', {tagOrId: 'all'});

                // Set the property async, or it might be set too early for the template
                this.async(function() {
                    this.routeParamObserver('feed', 'tagOrId', function(value) {
                        // Force the notification
                        if (this.tagOrId == value) {
                            this.tagOrId = "";
                        }
                        this.tagOrId = value;

                        if (value.startsWith("search:")) {
                            this.searchVisible = true;
                            var term = this._extractSearchTokens(value)[1];

                            Polymer.dom(this.root).querySelectorAll('.search-input').forEach(function(input) {
                                input.value = term;
                            });
                        }
                    }.bind(this));

                    this.routeParamObserver('article', 'articleId', function(value) {
                        this._articleId = value;
                        this.cancelDebouncer('article-read-state');
                        this._readState = this.$.feed.articleState(value).Read;
                        this._ignoreReadDebouncer = false;
                    }.bind(this));
                });
            },

            onFeedArticleState: function(event, detail) {
                if ('Read' in detail) {
                    if (this._ignoreReadDebouncer) {
                        this._readState = detail.Read;
                        this._ignoreReadDebouncer = false;
                    } else {
                        this.debounce('article-read-state', function() {
                            this._readState = detail.Read;
                        }, 1000);
                    }
                }
            },

            onAllFeedsMessage: function(event, detail) {
                this.feeds = detail.arguments.Feeds;
            },

            onSignalFeedsChanged: function() {
                this.$['list-feeds'].send();
            },

            onSignalFeedTagsChanged: function(event, detail) {
                for (var i = 0, f; f = this.feeds[i]; ++i) {
                    if (f.Id == detail.Id) {
                        f.Tags = detail.Tags;

                        this.updateTags();
                        this.set('feeds.' + i, f);
                    }
                }
            },

            onToggleExpand: function(event) {
                var element = Polymer.dom(event).localTarget;

                var collapser = Polymer.dom(this.root).querySelector(
                        '#' + element.getAttribute('expands'));

                if ('icon' in element) {
                    element.icon = collapser.opened ? 'expand-more' : 'expand-less';
                }
                collapser.toggle();
            },

            onArticleUp: function() {
                MoreRouting.navigateTo('feed', {tagOrId: MoreRouting.getRoute('feed').params.tagOrId});
            },

            onReadStateTap: function(event) {
                var element = Polymer.dom(event).localTarget;

                this._ignoreReadDebouncer = true;
                this.flushDebouncer('article-read-state');
                this.$.feed.articleState(this._articleId,
                    {Read: !this.$.feed.articleState(this._articleId).Read});
            },

            onPreviousArticle: function() {
                this.$.feed.previousArticle();
            },

            onNextArticle: function() {
                this.$.feed.nextArticle();
            },

            onRefresh: function() {
                MoreRouting.navigateTo('feed', {tagOrId: MoreRouting.getRoute('feed').params.tagOrId});
                this.$.feed.refresh();
            },

            onFeedMenuItemActivate: function(event) {
                // Event is fired before the actual selection takes place
                var menu = Polymer.dom(event).localTarget,
                    name = event.detail.selected,
                    selected = (menu.selectedValues || []).indexOf(name) == -1;

                switch (name) {
                case "newer-first":
                    this.set("user.ProfileData.newerFirst", selected)
                    this.$.feed.refresh();
                    break;
                case "unread-only":
                    this.set("user.ProfileData.unreadOnly", selected)
                    this.$.feed.refresh();
                    break;
                case "mark-all-as-read":
                    if (selected) {
                        menu.select(name);
                    }
                    break;
                }
            },

            onSearchKeypress: function(event) {
                var code = event.keyCode || event.charCode, key = event.keyIdentifier,
                    target = Polymer.dom(event).localTarget;

                if (key == 'Enter' || code == 13) {
                    MoreRouting.navigateTo('feed', {
                        tagOrId: "search:" + this.tagOrId + ":" + target.value,
                    });
                }
            },


            _feedsChanged: function(newValue, oldValue) {
                this.updateTags();
            },

            _userProfileChanged: function(userProfileRecord) {
                this.$['user-settings'].send({
                    attribute: "ProfileData",
                    value: this.user.ProfileData
                });
            },

            _computeFeedTitle: function(tagOrId) {
                if (tagOrId == "all") {
                    return "All feed articles";
                } else if (tagOrId == "favorite") {
                    return "Favorite feed articles";
                } else if (tagOrId.startsWith("popular:")) {
                    var sub = tagOrId.substring("popular:".length);

                    if (sub == "all") {
                        return "Popular feed articles";
                    } else if (sub.startsWith("tag:")) {
                        return "Popular articles from " + tagOrId.substring("tag:".length);
                    } else if (!isNaN(sub)) {
                        var feed = this.feeds.filter(function(f) { return f.Id == sub })[0];
                        if (feed) {
                            return "Popular articles from " + feed.Title;
                        }
                    }
                } else if (tagOrId.startsWith("search:")) {
                    var parts = this._extractSearchTokens(tagOrId),
                        sub = parts[0],
                        term = parts[1],
                        base = "Search results for " + term;;

                    if (sub == "all") {
                        return base;
                    } else if (sub.startsWith("tag:")) {
                        return base + "  from " + tagOrId.substring("tag:".length);
                    } else if (!isNaN(sub)) {
                        var feed = this.feeds.filter(function(f) { return f.Id == sub })[0];
                        if (feed) {
                            return base + " from " + feed.Title;
                        }
                    }
                } else if (tagOrId.startsWith("tag:")) {
                    var sub = tagOrId.substring("tag:".length);

                    return "Articles from " + sub;
                } else if (!isNaN(tagOrId)) {
                    var feed = (this.feeds || []).filter(function(f) { return f.Id == tagOrId })[0];
                    if (feed) {
                        return feed.Title;
                    }
                }
            },

            _computeHideFeedItems: function(feeds) {
                return this.feeds == 0;
            },

            _computeFavIconUrl: function(feed) {
                this._urlParser.href = feed.Link

                return "//www.google.com/s2/favicons?domain=" + this._urlParser.host;
            },

            _computeNavigationTags: function(tags) {
                return [].concat({name: 'All', feeds: this.feeds}, this.tags);
            },

            _computeNavigationExpandTag: function(item) {
                return 'feeds-' + item.name;
            },

            _computeOptionsMenuSelectedValues: function(userRecord) {
                var selected = [];

                if (this.user.ProfileData.newerFirst) {
                    selected.push("newer-first");
                }

                if (this.user.ProfileData.unreadOnly) {
                    selected.push("unreadOnly");
                }

                return selected;
            },

            _computeReadStateIcon: function(readState) {
                return readState ? 'check-box' : 'check-box-outline-blank';
            },

            _computeHideArticleArrow(articleId, direction) {
                if (direction == 'previous') {
                    return this.$.feed.hasPreviousArticle(articleId) ? "" : "visibility: hidden";
                } else {
                    return this.$.feed.hasNextArticle(articleId) ? "" : "visibility: hidden";
                }
            },

            _extractSearchTokens: function(tagOrId) {
                var parts = tagOrId.split(":"), term, sub;

                parts.shift();
                sub = parts[0];

                if (sub == "tag") {
                    sub = parts.splice(0, 2).join(":")
                } else {
                    sub = parts.shift();
                }

                term = decodeURIComponent(parts.join(":"));

                return [sub, term];
            },
        })
    </script>
</dom-module>
{% end %}
